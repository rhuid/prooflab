\documentclass[11pt, oneside]{report}
\usepackage{/home/ronald/gits/tex-craft/spring}

\title{A Hoare-logic-based verifier for an imperative DSL}
\author{Ronald Huidrom}
\date{Dec 22, 2025}

\begin{document}
\maketitle

\begin{abstract}
We design an imperative language and a mechanized Hoare-logic-based verifier for the same. The design is implemented and proved sound in Lean theorem prover. Then we present some verified case studies.
\end{abstract}

\vfill
\tableofcontents
\vfill

\clearpage
\chapter{Introduction}

Consider the following function definition:

\begin{leanblock}
def divide (x : ℕ) (y : ℕ) (h : y ≠ 0) := x / y
\end{leanblock}

This is the usual definition of a division function for natural numbers, except that instead of
taking two arguments it takes three. By \lean{x : ℕ}, we mean that \lean{x} is a term having the
type \lean{ℕ} (the colon annotates the type). The third argument \lean{h} has the type \lean{y ≠ 0}.
This is a proposition and, furthermore, it depends on the value of the term \lean{y}.

This is an instance of \emph{dependent type theory}, in which types may depend on terms.
By the Curry--Howard isomorphism and the \emph{propositions-as-types, proofs-as-terms}
viewpoint, a term of type \lean{y ≠ 0} is precisely a proof of that proposition. Therefore, the
function \lean{divide} can only be evaluated when we supply a proof that \lean{y} is nonzero as its
third argument.

A typical evaluation of the function would be:

\begin{leanblock}
#eval divide 10 2 (by decide)
\end{leanblock}

Without going into details (which are delegated to later chapters), \lean{by decide} constructs
a term of the required type, in this case a proof of \lean{2 ≠ 0}.

\bigskip

Now consider the following code:

\begin{leanblock}
inductive NonEmptyList (α : Type) where
| mk : (xs : List α) → xs ≠ [] → NonEmptyList α
\end{leanblock}

The keyword \lean{inductive} creates an inductive data type named \lean{NonEmptyList α}.
Here, \lean{α} is an arbitrary type (for example, \lean{String}), in which case
\lean{NonEmptyList String} denotes the type of non-empty lists of strings.

This inductive type has a single constructor \lean{mk}. Outside the definition, it is referred
to as \lean{NonEmptyList.mk}, where the dot denotes a namespace (or simply \lean{.mk} when
the namespace can be inferred).

This means that there is exactly one way to construct a term of type \lean{NonEmptyList α},
namely by using the constructor

\begin{leanblock}
NonEmptyList.mk : (xs : List α) → xs ≠ [] → NonEmptyList α
\end{leanblock}

The type of this constructor can be understood as follows: it takes two arguments,
\begin{itemize}[noitemsep]
\item a term \lean{xs} of type \lean{List α}, and
\item a term of type \lean{xs ≠ []},
\end{itemize}
and returns a term of type \lean{NonEmptyList α}.

The second argument is particularly interesting: it requires a proof that the first argument
\lean{xs} is non-empty. This is again an instance of dependent type theory, since the type
\lean{xs ≠ []} depends on the term \lean{xs}.

\bigskip

Now consider the following definition:

\begin{leanblock}
def NonEmptyList.head {α} : NonEmptyList α → α
| .mk (x :: _) _ => x
| .mk [] h => (h rfl).elim
\end{leanblock}

This definition implements the well-known \lean{head} function. Its type is

\begin{leanblock}
NonEmptyList α → α
\end{leanblock}

meaning that it takes a non-empty list of elements of type \lean{α} and returns an element of
type \lean{α}.

In the function body, we use pattern matching to destruct the possible cases of a term of type \lean{NonEmptyList α}.
Since such a term can only be constructed using its constructor
(this follows from the inductive definition), the cases listed above are exhaustive.

The first case is when the list has the form \lean{x :: _}, in which case \lean{x} is clearly the first
element of the list. (The underscore \lean{_} acts as a wildcard matching the remainder of the
list. For example, the list \lean{[1,2,3]} is written as \lean{1 :: [2, 3]}.)

The second case considers the empty list \lean{[]}. However, in this case \lean{h} is a proof
that \lean{[]} is non-empty. Examining the type of \lean{NonEmptyList.mk} reveals that \lean{h} has
type \lean{[] ≠ []}. This proposition is definitionally equal to \lean{[] = [] → False}.
Since \lean{rfl} is a proof of \lean{[] = []}, the expression \lean{h rfl} yields a contradiction, that is, a
term of type \lean{False}.

The expression \lean{(h rfl).elim} invokes \lean{False.elim}, which expresses
the logical principle that from a contradiction, anything follows. This allows us to construct a
term of type \lean{α}, thereby convincing Lean that this case is impossible.

\bigskip

All the code discussed above is written in Lean. We have seen that the type of a function can
already guarantee its correctness: impossible cases are ruled out by logical reasoning. By
allowing types to depend on runtime values, we eliminate entire classes of runtime errors.

Lean is both a general-purpose functional programming language and an interactive theorem
prover, based on the calculus of inductive constructions and dependent type theory.

\clearpage

\section{Introduction}

Consider the following function definition:

\begin{leanblock}
def divide (x : ℕ) (y : ℕ) (h : y ≠ 0) := x / y
\end{leanblock}

The declaration above is the usual integer division operation on natural numbers, except that the function takes an additional \emph{proof} argument. By \lean{x : ℕ} we mean that \lean{x} is a term of type \lean{ℕ}; the third parameter \lean{h} has type \lean{y ≠ 0}, a proposition that depends on the value of \lean{y}. In other words, the function is not just \emph{typed} but \emph{indexed} by a proposition: it is a dependent function.

Under the Curry–Howard correspondence (propositions-as-types, proofs-as-terms), a term of type \lean{y ≠ 0} is exactly a witness (a proof) that \lean{y} is nonzero. Thus \lean{divide} can only be applied when the caller supplies such a witness. For example:

\begin{leanblock}
#eval divide 10 2 (by decide)
\end{leanblock}

Here \lean{by decide} constructs the required proof term (a certificate that \lean{2 ≠ 0}), and the evaluation proceeds without any runtime check.

\bigskip

Now consider this inductive type:

\begin{leanblock}
inductive NonEmptyList (α : Type) where
| mk : (xs : List α) → xs ≠ [] → NonEmptyList α
\end{leanblock}

The \lean{inductive} declaration defines \lean{NonEmptyList α} as the type of non-empty lists over \lean{α}. Its single constructor, \lean{NonEmptyList.mk}, has the dependent type
\begin{leanblock}
NonEmptyList.mk : (xs : List α) → xs ≠ [] → NonEmptyList α
\end{leanblock}
which reads: given a list \lean{xs : List α} and a proof of \lean{xs ≠ []}, construct an element of \lean{NonEmptyList α}. The second argument is a \emph{proof obligation} that enforces the invariant ``the list is not empty'' at the type level.

We can now implement a safe head projection:

\begin{leanblock}
def NonEmptyList.head {α} : NonEmptyList α → α
| .mk (x :: _) _ => x
| .mk [] h => (h rfl).elim
\end{leanblock}

The pattern match is exhaustive because every \lean{NonEmptyList α} is built with \lean{.mk}. In the first clause the payload has the form \lean{x :: _} and we return the head \lean{x}. The second clause is logically impossible: it matches the empty list \lean{[]} while \lean{h} is a proof of \lean{[] ≠ []}. Applying \lean{h} to \lean{rfl} (the canonical proof of judgmental equality \lean{[] = []}) yields a term of type \lean{False}; invoking \lean{(h rfl).elim} eliminates the contradiction (by \lean{False.elim}) and thus produces a term of the expected return type. In short, the impossible branch is discharged by logical contradiction rather than by a runtime error.

\bigskip

These examples illustrate a central design point of dependent-type proof assistants: invariants that would otherwise require runtime checks are encoded in the type system and discharged by supplying proof terms. By making propositions first-class and allowing types to depend on terms, Lean (based on the Calculus of Inductive Constructions) moves many correctness obligations from runtime into the type checker. The payoff is strong: programs and proofs can be composed so that certain classes of runtime failures are provably impossible.

% \chapter{Background}
\chapter{The Imperative DSL}

We design a minimal imperative language sufficient to express classical algorithms such as binary search. The language is intentionally small, allowing us to focus on the logical foundations of verification rather than engineering concerns.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% Some text here %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{leanblock}
% /-- A function that evaluates arithmetic expressions -/
% def AExp.eval : AExp → State → Int
% | .const n, _ => n
% | .var x, s => s x
% | .add e₁ e₂, s => e₁.eval s + e₂.eval s
% | .sub e₁ e₂, s => e₁.eval s - e₂.eval s
% | .mul e₁ e₂, s => e₁.eval s * e₂.eval s
% \end{leanblock}

% \begin{leanblock}
% def BExp.eval : BExp → State → Prop
% | .tt, _ => True
% | .ff, _ => False
% | .eq e₁ e₂, s => e₁.eval s = e₂.eval s
% | .le e₁ e₂, s => e₁.eval s ≤ e₂.eval s
% | .not b, s => ¬ b.eval s
% | .and b₁ b₂, s => b₁.eval s ∧ b₂.eval s
% \end{leanblock}

% \begin{leanblock}
% inductive Cmd
% | skip
% | assign (x : Var) (e : AExp)
% | seq    (c₁ c₂ : Cmd)
% | ite    (b : BExp) (ct ce : Cmd)
% | while  (b : BExp) (I : Assertion) (c : Cmd)
% \end{leanblock}

\section{Operational semantics}

\subsection{Big-step (natural) operational semantics}

We adopt a \emph{big-step} (also called \emph{natural}) operational semantics for our imperative DSL.  Intuitively, a big-step judgment
\[
\langle c, s\rangle \Downarrow s'
\]
asserts that executing command \(c\) in initial state \(s\) \emph{terminates} and produces final state \(s'\).  The big-step semantics is given by a small collection of inference rules (one rule per syntactic form); each rule is a specification of how one execution step (or one inference of a case) yields a final state.  In contrast to small-step semantics, the big-step form directly relates whole computations to their results and thus is particularly convenient when proving partial-correctness properties (such as soundness of Hoare logic) and when constructing verification condition generators.

Below we present the operational rules in standard inference–rule form.  For clarity we write states as \(s, s', s''\), commands as \(c, c_1, c_2\), and use the notation \(\langle c, s\rangle \Downarrow s'\) for the big-step relation.

\medskip
\noindent\textbf{Inference rules (big-step).}

\medskip
\noindent\textbf{(skip)}\quad The \(\texttt{skip}\) command does nothing.
\[
\AxiomC{}
\UnaryInfC{\(\langle \texttt{skip}, s\rangle \Downarrow s\)}
\DisplayProof
\]

\medskip
\noindent\textbf{(assign)}\quad Assignment updates the state at the named variable with the value of the expression.
\[
\AxiomC{}
\UnaryInfC{\(\langle x := e, s\rangle \Downarrow s[x \mapsto \mathsf{eval}(e,s)]\)}
\DisplayProof
\]

\medskip
\noindent\textbf{(seq)}\quad Sequential composition executes the first command to an intermediate state and then the second.
\[
\AxiomC{\(\langle c_1, s\rangle \Downarrow s'\)}
\AxiomC{\(\langle c_2, s'\rangle \Downarrow s''\)}
\BinaryInfC{\(\langle c_1; c_2, s\rangle \Downarrow s''\)}
\DisplayProof
\]

\medskip
\noindent\textbf{(if\_true)}\quad If the condition holds, execute the then-branch.
\[
\AxiomC{\(\mathsf{evalB}(b,s)\)}
\AxiomC{\(\langle c_{\mathit{then}}, s\rangle \Downarrow s'\)}
\BinaryInfC{\(\langle \texttt{if } b \texttt{ then } c_{\mathit{then}} \texttt{ else } c_{\mathit{else}}, s\rangle \Downarrow s'\)}
\DisplayProof
\]

\medskip
\noindent\textbf{(if\_false)}\quad Otherwise, execute the else-branch.
\[
\AxiomC{\(\neg \mathsf{evalB}(b,s)\)}
\AxiomC{\(\langle c_{\mathit{else}}, s\rangle \Downarrow s'\)}
\BinaryInfC{\(\langle \texttt{if } b \texttt{ then } c_{\mathit{then}} \texttt{ else } c_{\mathit{else}}, s\rangle \Downarrow s'\)}
\DisplayProof
\]

\medskip
\noindent\textbf{(while\_false)}\quad If the loop guard is false initially, the loop terminates immediately.
\[
\AxiomC{\(\neg\mathsf{evalB}(b,s)\)}
\UnaryInfC{\(\langle \texttt{while } b \texttt{ do } c, s\rangle \Downarrow s\)}
\DisplayProof
\]

\medskip
\noindent\textbf{(while\_true)}\quad If the guard is true, execute one iteration and continue.
\[
\AxiomC{\(\mathsf{evalB}(b,s)\)}
\AxiomC{\(\langle c, s\rangle \Downarrow s'\)}
\AxiomC{\(\langle \texttt{while } b \texttt{ do } c, s'\rangle \Downarrow s''\)}
\TrinaryInfC{\(\langle \texttt{while } b \texttt{ do } c, s\rangle \Downarrow s''\)}
\DisplayProof
\]

\bigskip

The rules above are the standard natural semantics for the command language: they are \emph{compositional} (the conclusion of a rule is determined from the conclusions of its premises) and they explicitly witness termination.  In particular, the \textbf{while\_true} rule unrolls one iteration of the loop and then recurses, so a proof of a loop execution is finite precisely when the loop terminates; non-terminating executions produce no finite derivation and therefore no judgment \(\langle c, s\rangle \Downarrow s'\).

\subsection{The Lean representation: the inductive relation \lean{Exec}}

In the formal development we encode the above semantics as an inductive relation in Lean named \lean{Exec}.  The relation has the (dependent) type
\begin{leanblock}
Exec : Cmd → State → State → Prop
\end{leanblock}

so that a value (term) of type \lean{Exec c s s'} is a formal derivation witnessing \(\langle c, s\rangle \Downarrow s'\).

Below is the Lean declaration:

\begin{leanblock}
inductive Exec : Cmd → State → State → Prop
| skip : Exec Cmd.skip s s
| assign : Exec (Cmd.assign x e) s (s.update x (e.eval s))
| seq : Exec c₁ s s' → Exec c₂ s' s'' → Exec (Cmd.seq c₁ c₂) s s''
| ite_true : b.eval s → Exec ct s s' → Exec (Cmd.ite b ct ce) s s'
| ite_false : ¬ b.eval s → Exec ce s s' → Exec (Cmd.ite b ct ce) s s'
| while_false : ¬ b.eval s → Exec (Cmd.while b I c) s s
| while_true : b.eval s → Exec c s s' → Exec (Cmd.while b I c) s' s'' →
               Exec (Cmd.while b I c) s s''
\end{leanblock}

\subsection{How to build \lean{Exec} terms}

Each constructor of \lean{Exec} corresponds exactly to one of the inference rules above.  A proof object of type \lean{Exec c s s'} is a finite tree whose internal nodes are applications of constructors and whose leaves are applications of leaf constructors (e.g., \lean{skip} and \lean{assign}).  We now describe the constructors and how to form terms in practice.

\begin{description} [leftmargin=1.6cm,noitemsep]
\item[\textbf{\lean{skip}.}] The constructor \lean{Exec.skip} (named \lean{skip} in the inductive block) is a leaf constructor.  For any state \lean{s} the term \lean{Exec.skip} inhabits \lean{Exec Cmd.skip s s}.  Thus the trivial derivation \(\langle\texttt{skip},s\rangle\Downarrow s\) is witnessed by the canonical term \lean{Exec.skip}.

\item[\textbf{\lean{assign}.}] The assignment constructor is also a leaf: to prove \lean{Exec (Cmd.assign x e) s s'}, the constructor requires that \lean{s' = s.update x (e.eval s)}.  Concretely, for any state \lean{s} the term \lean{Exec.assign} is a witness of
\begin{leanblock}
Exec (Cmd.assign x e) s (s.update x (e.eval s))
\end{leanblock}

No additional premises are needed because the evaluation of the right-hand expression \(\mathsf{eval}(e,s)\) is computed meta-level (by the definitional evaluator \lean{e.eval s}).

\item[\textbf{\lean{seq}.}] The sequential composition constructor is \emph{binary} and nontrivial. If we have:
\begin{center}
\lean{h_1 : Exec c₁ s s'} and \lean{h_2 : Exec c₂ s' s''}
\end{center}
then the term \lean{Exec.seq h_1 h_2} has type

\begin{leanblock}
Exec (Cmd.seq c₁ c₂) s s''
\end{leanblock}

Thus, to build a proof that a sequence terminates in state \lean{s''}, we must provide a proof for the first component reaching an intermediate state \lean{s'} and a proof that the second component reaches \lean{s''} from \lean{s'}.

\item[\textbf{\lean{ite_true} / \lean{ite_false}.}] Conditionals have two constructors corresponding to the two branches.  To construct a term of type \lean{Exec (Cmd.ite b ct ce) s s'} in the \emph{true} case we must provide:
\begin{center}
\lean{hb : b.eval s} and \lean{ht : Exec ct s s'}.
\end{center}
Then \lean{Exec.ite_true hb ht} is a witness of the execution along the then-branch. The false case is analogous and uses \lean{Exec.ite_false}.

\item[\textbf{\lean{while_false}.}] If the guard is false in the starting state, then the loop terminates immediately and the constructor \lean{Exec.while_false} (given a proof of \(\neg b.eval\ s\)) builds a term of type \lean{Exec (Cmd.while b I c) s s}.

\item[\textbf{\lean{while_true}.}] The \lean{while_true} constructor implements one unrolling of the loop. To construct a witness of type

\begin{leanblock}
Exec (Cmd.while b I c) s s''
\end{leanblock}

we must provide:
\begin{enumerate}[noitemsep]
  \item a proof \lean{hb : b.eval s} that the guard holds at the current state,
  \item a proof \lean{hbody : Exec c s s'} that one iteration executes from \lean{s} to \lean{s'}, and
  \item a proof \lean{hrest : Exec (Cmd.while b I c) s' s''} that the remainder of the loop executes from \lean{s'} to \lean{s''}.
\end{enumerate}
One then forms \lean{Exec.while_true hb hbody hrest}. Because the final premise is itself an \lean{Exec} judgment, proofs of loop executions are nested finite trees that correspond to successive unrollings.  A complete derivation is finite exactly when the loop terminates in a finite number of iterations.
\end{description}

\subsection{Key meta-properties and remarks}

\begin{enumerate}[leftmargin=1.2cm]
\item \textbf{Derivations are finite trees.} Since \lean{Exec} is declared \emph{inductively}, every inhabitant (proof term) is a finite, well-founded tree built from the constructors.  This enforces the standard semantic reading: \emph{a big-step derivation exists precisely when the program terminates}; nonterminating computations have no finite \lean{Exec} witness.

\item \textbf{Not recursion in the proof-theoretic sense.} Although several constructors (notably \lean{seq} and \lean{while_true}) mention \lean{Exec} in their premises, this is inductive recursion — not unrestricted recursion — and Lean checks that the definition is well-formed.  Inductive definitions produce the least fixed point; hence all constructed proofs are finite by construction.

\item \textbf{Constructing proofs vs. running programs.} A term of type \lean{Exec c s s'} is a \emph{certificate} (derivation) rather than an imperative execution performed by the Lean VM.  When the program consists of pure assignments and conditionals evaluated by definitional evaluation of subexpressions, the premises used in constructors will often be inhabited by canonical constructors (e.g., \lean{Exec.assign}) without additional work; however, for loops a proof requires exhibiting a finite sequence of iterations (or a loop invariant if reasoning by Hoare logic).

\item \textbf{Partial correctness and Hoare triples.} The big-step relation provides the semantic basis for partial correctness.  We define the semantic Hoare triple by
\[
\{P\}\ c\ \{Q\}\quad\stackrel{\mathsf{def}}{\iff}\quad
\forall s\, s',\ \langle c, s\rangle \Downarrow s' \ \wedge\ P(s)\ \Rightarrow\ Q(s').
\]
In Lean notation this is written directly as:
\begin{leanblock}
def Hoare (P : Assertion) (c : Cmd) (Q : Assertion) : Prop :=
  ∀ s s', Exec c s s' → P s → Q s'
\end{leanblock}
Soundness of a proof system (e.g. Hoare rules) or of a verification condition generator is proved with respect to this semantic definition.

\item \textbf{Determinism (optional remark).} For typical deterministic expression evaluation and the rules above, the big-step relation is deterministic: if \(\langle c, s\rangle \Downarrow s_1\) and \(\langle c, s\rangle \Downarrow s_2\) then \(s_1 = s_2\).  Determinism is convenient for equational reasoning and can be proved by induction on derivations; it is not strictly required for the verification machinery, but it simplifies many meta-proofs.

\item \textbf{Proof engineering.} In practice, one seldom constructs large \lean{Exec} trees by hand; instead, we either:
  \begin{itemize}[noitemsep]
  \item reason about them abstractly using induction on derivations, or
  \item avoid explicit derivations by using a verification condition generator (VCG) whose correctness is proved against the \lean{Exec} relation.
  \end{itemize}
  The VCG produces logical obligations (assertions) that imply the existence of an \lean{Exec} derivation; thus the VCG plus discharged obligations yields a semantic guarantee \`a la the Hoare triple above.
\end{enumerate}

\subsection{A short concrete construction example}

Consider the trivial program that performs two assignments in sequence:
\begin{leanblock}
def c1 : Cmd := Cmd.assign "x" (AExp.const 1)
def c2 : Cmd := Cmd.assign "y" (AExp.const 2)
def prog : Cmd := Cmd.seq c1 c2
\end{leanblock}

Let \lean{s} be an arbitrary state and define \lean{s1 := s.update "x" 1} and \lean{s2 := s1.update "y" 2}.  Then we obtain the following concrete derivation terms:

\begin{leanblock}
# let h1 : Exec c1 s s1 := Exec.assign
# let h2 : Exec c2 s1 s2 := Exec.assign
# let hprog : Exec prog s s2 := Exec.seq h1 h2
\end{leanblock}

In words: both assignments are leaf derivations (inhabited by \lean{Exec.assign}); composing them with \lean{Exec.seq} yields a derivation of the full sequence.

\bigskip

\noindent\textbf{Concluding remark.} The inductive relation \lean{Exec} and its finite derivations give a transparent, machine-checkable account of terminating executions.  It is the semantic backbone for correctness statements and for proving soundness of the verification infrastructure (VCG or Hoare proof system) that we build on top of the DSL.

% \chapter{Hoare Logic}

The verification condition generator is implemented as a structurally recursive function over the abstract syntax of the language, entirely within Lean’s definitional fragment, without the use of metaprogramming.

\end{document}
