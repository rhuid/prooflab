% Created 2025-11-28 Fri 19:34
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{H. Ronald}
\date{Nov 28, 2025}
\title{Formalization and Verification with Lean}
\hypersetup{
 pdfauthor={H. Ronald},
 pdftitle={Formalization and Verification with Lean},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 30.1 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setcounter{tocdepth}{1}
\tableofcontents

\section{Introduction}
\label{sec:org333bd00}
\subsection{Lean}
\label{sec:org8964a0c}
\begin{itemize}
\item Functional programming language
\item Theorem prover
\item Based on Calculus of inductive constructions (CIC)
\begin{itemize}
\item Inductive types + calculus of constructions (CoC)
\end{itemize}
\item Calculus of constructions
\begin{itemize}
\item Higher-order typed lambda calculus
\item Curry-Howard
\end{itemize}
\item Propositions are types, proofs are terms (programs)
\begin{itemize}
\item Proving = type checking
\end{itemize}
\item Lean uses CIC + universe polymorphism
\end{itemize}
\subsection{Type theory of Lean}
\label{sec:org418f02a}
\begin{itemize}
\item Dependent type theory
\item Types can depend on values
\end{itemize}

\begin{verbatim}
def divide (x y : Nat) (h : y ≠ 0) : Nat := x / y
\end{verbatim}

\begin{itemize}
\item Types can be indexed by runtime values
\end{itemize}

\begin{verbatim}
def head {α : Type} {n : Nat} : Vector α (n + 1) → α
| ⟨data, h⟩ => data[0]
\end{verbatim}

A dependent type theoretic implementation of the function

\texttt{head}: [α] → α

\begin{verbatim}
inductive NonEmptyList (α : Type) where
| mk : (xs : List α) → xs ≠ [] → NonEmptyList α

def NonEmptyList.head {α} : NonEmptyList α → α
| .mk (x :: _) _ => x
| .mk [] h => (h rfl).elim
\end{verbatim}

\begin{itemize}
\item Type of the function already guarantees correctness
\item Impossible cases are removed by logical reasoning
\item No runtime errors
\end{itemize}
\section{Theorem Proving}
\label{sec:org22f0d21}
\begin{itemize}
\item p \(\to\) q is a proposition
\begin{itemize}
\item but also a function that takes a term of type p as input and outputs a term of type q
\end{itemize}
\item Two ways
\begin{itemize}
\item Construct lambda terms of the required type
\item Tactic mode
\end{itemize}
\end{itemize}
\subsection{Tactics}
\label{sec:org1b6fb90}
\begin{itemize}
\item Two important tactics are \texttt{intro} and \texttt{apply}
\item \texttt{intro} (assume, declaration)
\begin{itemize}
\item introduces or brings assumptions in local context
\item want to prove p → q → r
\item bring proofs of \texttt{p} and \texttt{q} in the local context
\end{itemize}
\item \texttt{apply} (function application)
\begin{itemize}
\item want to prove \texttt{r : Prop}
\item suppose we have the function (constructor) x : a → r
\item \texttt{apply x} would reduce the goal to proving \texttt{a}
\end{itemize}
\end{itemize}

\begin{itemize}
\item Local context
\item Goal (or goals or subgoals)
\begin{itemize}
\item Applying f : p → q → r → s to the goal s will gives us three subgoals p, q and r
\end{itemize}
\end{itemize}

\begin{verbatim}
example (P Q : Nat → Prop) : (∃ x, P x ∧ Q x) → ∃ x, Q x ∧ P x := by
  intro h
  cases h with
  | intro k hpq =>
    cases hpq with
    | intro hp hq => constructor ; apply And.intro ; exact hq ; exact hp
\end{verbatim}

\begin{itemize}
\item A brief demo of tactic mode
\end{itemize}
\subsection{Lambda terms as proofs}
\label{sec:org8a453a3}
\begin{itemize}
\item To prove p → q, we write a lambda term of that type
\item Can switch between tactic mode and term mode
\item An example below (resolution rule)
\end{itemize}

\begin{verbatim}
example : (p ∨ A) ∧ (¬p ∨ B) → A ∨ B :=
  fun ⟨ha, hb⟩ =>
  match ha with
  | Or.inl hp =>
    match hb with
    | Or.inl hnp => absurd hp hnp
    | Or.inr h   => Or.inr h
  | Or.inr h  => Or.inl h
\end{verbatim}

Lean also provides tools for working with Classical logic

\begin{itemize}
\item For any proposition \texttt{p}, \texttt{Classical.em p} gives a term of type \texttt{p ∨ ¬p}.
\end{itemize}

\begin{verbatim}
example : ¬(p ∧ ¬q) → (p → q) :=
  fun h : ¬(p ∧ ¬q) =>
  fun hp =>
  Or.elim (Classical.em q)
  (fun hq  :  q => hq)
  (fun hnq : ¬q => absurd ⟨hp, hnq⟩ h)
\end{verbatim}

\begin{itemize}
\item \texttt{if else} and Pierce's law
\end{itemize}
Using if else automatically activates Classical.em

\begin{verbatim}
example : ((p → q) → p) → p :=
  fun h =>
  if hp : p then hp
  else let hpq : p → q := fun hp' => absurd hp' hp
  h hpq
\end{verbatim}
\section{Functional Programming}
\label{sec:org180e0ca}
\subsection{Inductive types}
\label{sec:org097c3a9}
\begin{verbatim}
inductive Even : Nat → Prop
| zero : Even 0
| next : ∀ n : Nat, Even n → Even (n + 2)
\end{verbatim}

Inductive types for logical connectives

\begin{verbatim}
inductive And' (p q : Prop) : Prop
| intro : p → q → And' p q
\end{verbatim}

\begin{verbatim}
inductive Or' : Prop → Prop → Prop
| inl : p → Or' p q
| inr : q → Or' p q
\end{verbatim}

Inductive definition gives constructors and destructors

\begin{itemize}
\item Use constructors as introduction rules
\item Use case analysis on constructors (cases/induction) as elimination rules
\end{itemize}

The following are elimination rules for And.

\begin{verbatim}
theorem And'.left : And' p q → p := by
  intro hpq
  cases hpq with
  | intro => assumption                    -- use of unnamed hypotheses

theorem And'.right : And' p q → q := by
  intro hpq
  cases hpq with
  | intro => assumption
\end{verbatim}

A simple example (p ∧ q → q ∧ p):

\begin{verbatim}
example (p q : Prop) : And' p q → And' q p := by
  intro hpq
  have hp : p := And'.left  hpq
  have hq : q := And'.right hpq
  exact And'.intro hq hp
\end{verbatim}

Likewise, for existential statements and XOR operations.

\begin{verbatim}
inductive Exists' {α : Type} (P : α → Prop) : Prop
| intro : (a : α) → P a → Exists' P

inductive Xor' : Prop → Prop → Prop
| inl : p → ¬q → Xor' p q
| inr : ¬p → q → Xor' p q
\end{verbatim}
\subsection{Monads}
\label{sec:orgdf8a9d1}
\begin{itemize}
\item Type constructor (Type → Type)
\item Two functions
\begin{itemize}
\item pure (return, unit)
\item bind (join, multiplication)
\end{itemize}
\item Obeys three laws
\begin{itemize}
\item Two identity laws
\item Associativity
\end{itemize}
\end{itemize}

\begin{verbatim}
class Monad' (m : Type → Type) where
pure : α → m α
bind : m α → (α → m β) → m β

class LawfulMonad' (m : Type → Type) extends Monad' m where
pure_bind (a : α) (f : α → m β) :
  bind (pure a) f = f a
bind_pure (ma : m α) :
  bind ma (pure) = ma
bind_assoc (f : α → m β) (g : β → m γ) (ma : m α) :
  bind (bind ma f) g = bind ma (fun a => bind (f a) g)
\end{verbatim}

Why monads?

\begin{itemize}
\item Write pure functional programs in imperative style
\item All tactics proofs are just monadic operations
\begin{itemize}
\item Tactic execution, logging, metavariable manipulation, backtracking, etc. are effectful
\item Tactics must fail cleanly (\texttt{throwError}), try alternatives (\texttt{try}, \texttt{first}), brach, backtrack automatically
\end{itemize}
\item Metaprogramming (we will see soon enough)
\item Verification (we will see soon enough)
\end{itemize}
\subsection{Anatomy of a tactic proof}
\label{sec:orgaafbf96}
\begin{itemize}
\item \texttt{MetaM}, \texttt{TacticM} monads
\item Every tactic execution
\begin{itemize}
\item reads environment (\texttt{Env})
\item mutates goal state
\item may fail
\item may backtrack
\item may log messages
\end{itemize}
\item Monads allows this composition so smoothly
\end{itemize}

\begin{itemize}
\item Every tactic (e.g., \texttt{intro}, \texttt{apply}, \texttt{rw}, \texttt{simp}) is a function\\
TacticState → TacticM TacticState
\begin{itemize}
\item reads the current state
\item performs an effect (modify goal, intro a binder, etc.)
\item returns the new state
\item or throws an error
\end{itemize}
\end{itemize}
\section{Automation}
\label{sec:orgc6525c2}
\begin{itemize}
\item Built-in tactics
\begin{itemize}
\item \texttt{rw}, \texttt{simp}
\end{itemize}
\item Tactic combinators
\begin{itemize}
\item \texttt{tac\_1 <;> tac\_2}
\item \texttt{repeat' tac}
\item \texttt{any\_goals tac}
\item \texttt{all\_goals tac}
\end{itemize}
\item \texttt{syntax} and \texttt{macro\_rules}
\begin{itemize}
\item Wrap up a procedure (or a programmed bunch of tactics) into one tactic
\end{itemize}
\end{itemize}
\subsection{Metaprogramming monads}
\label{sec:org7b9e319}
\texttt{MetaM}, \texttt{TacticM} are metaprogramming monads
\begin{itemize}
\item Manipulate goals and local context
\item Iterate over local context
\item Change goal list, close a goal
\end{itemize}

Using the built-in eliminator for AND:

\begin{verbatim}
example (h : a ∧ b ∧ c ∧ d) : d := by apply And.right (And.right (And.right h))
\end{verbatim}

With custom tactic \texttt{destruct\_and}:

\begin{verbatim}
example (h : a ∧ b ∧ c ∧ d) : c := by destruct_and h
\end{verbatim}

Another example is \texttt{prove\_direct}.
\section{Verification}
\label{sec:orgb4dfd36}
\begin{itemize}
\item Monads encode computations (\texttt{Option}, \texttt{StateM}, \texttt{TacticM})
\item A computation or a program can be thought of as a monad (M α)
\item Specification monad (W α) specific to a monad M α
\item Weakest precondition transformer WP\textsubscript{M} : M \(\alpha\) \(\to\) W \(\alpha\)
\item W is often chosen to be W α = (α → L) → L
\item Then WP : M α → (α → L) → L
\end{itemize}
\subsection{Loom}
\label{sec:org68ad7e3}
\begin{itemize}
\item A framework for automated generation of foundational multi-modal verifiers
\item The theoretical basis (in their words, "our main theoretical result") lies in transformer monads and transformer monad algebras
\end{itemize}

\begin{itemize}
\item M : monad (program)
\item L : assertion language (in which we will write preconditions and postconditions)
\begin{itemize}
\item \texttt{Prop}, σ → Prop
\end{itemize}
\item μ : M L → L (monad algebra)
\begin{itemize}
\item Given a computation that would return a postcondition, return the precondition that guarantees that postcondition after running that computation
\end{itemize}
\item Define WP m post = μ (fmap post m)
\begin{itemize}
\item Recall: post : α → L, m : M α, fmap post m : M L
\end{itemize}
\item Then WP has the type M α → (α → L) → L
\item Then the weakest precondition is given by WP m post
\end{itemize}

\begin{itemize}
\item Monad transformer
\begin{itemize}
\item Takes a monad, gives a monad
\item StateT transformer for StateM monad
\begin{itemize}
\item StateT σ M α ≅ σ → M (α × σ)
\end{itemize}
\item MaybeT M α ≅ M (Option α)
\end{itemize}
\item Why use monad transformers?
\begin{itemize}
\item Reuse the WP machinery we already have for the underlying monad M, rather then re-prove everything from scratch for StateT σ M
\item Can lift monad algebra/WP through transformers
\end{itemize}
\end{itemize}

\begin{itemize}
\item Monad transformer algebra
\begin{itemize}
\item is a pair (T, F)
\item F (endofunctor) will transform base assertion language L into the assertion language F(L) of T M
\begin{itemize}
\item e.g., for StateT, we have F L = σ → L
\end{itemize}
\end{itemize}
\item Lifted monad algebra
\begin{itemize}
\item Fμ : T M (F L) → F L
\item Recall: underlying monad algebra μ : M L → L
\end{itemize}
\item Fμ gives monad algebra for the transformed monad T M at transformed language F L
\item How do we construct Fμ?
\begin{itemize}
\item Use pattern-match on T and use μ
\end{itemize}
\item WP tm post = Fμ (fmap post tm)
\end{itemize}

How do we implement this for stateful computations?
\begin{itemize}
\item Decide the assertion language, L = σ → Prop
\item Write definition of StateT (involves instantiation of MonadTransformer typeclass)
\begin{itemize}
\item F L = σ → L (we saw this before)
\end{itemize}
\item Design μ : StateM (σ → Prop) → (σ → Prop) (involves proving laws of monad algebra)
\item Derive Fμ for StateT (algorithmic)
\item Mechanically evaluate WP m post = Fμ (fmap post m)
\item Generate verification conditions (VCs): \texttt{pre1 => wp} and hand off to an SMT solver
\end{itemize}
\subsection{Case Study: Cashmere}
\label{sec:orge02777a}
\begin{itemize}
\item \texttt{CashmereM}
\begin{itemize}
\item \texttt{NonDetT (ExceptT String (StateT Bal DivM))}
\end{itemize}
\item Bank operations
\begin{itemize}
\item Cash withdrawal, deposits, etc.
\end{itemize}
\item DSL (imperative-style)
\item \texttt{require}, \texttt{ensure}
\end{itemize}

Examples of Cashmere programs
\begin{itemize}
\item Withdraw an amount
\end{itemize}

\begin{verbatim}
bdef withdraw (amount : Nat) returns (u: Unit)
  ensures balance + amount = balanceOld do
  balance := balance - amount
  return

prove_correct withdraw by
loom_solve
\end{verbatim}

\begin{itemize}
\item Withdraw session (withdrawing multiple amounts)
\end{itemize}

\begin{verbatim}
open PartialCorrectness DemonicChoice in
bdef withdrawSession (amounts : List Nat) returns (u: Unit)
  ensures balance + amounts.sum = balanceOld do
  let mut tmp := amounts
  let balancePrev := balance
  while tmp.nonEmpty
  invariant balance + amounts.sum = balancePrev + tmp.sum
  do
    let amount := tmp.head!
    balance := balance - amount
    tmp := tmp.tail
  return

open PartialCorrectness DemonicChoice in
prove_correct withdrawSession by
loom_solve!
\end{verbatim}
\end{document}
