#+TITLE: Formalization and Verification with Lean
#+AUTHOR: H. Ronald
#+DATE: Nov 28, 2025
#+HTML_HEAD: <link rel="stylesheet" href="reveal-style.css" />
#+OPTIONS: toc:1
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js

* Introduction
** Lean
+ Functional programming language
+ Theorem prover
+ Based on Calculus of inductive constructions (CIC)
  + Inductive types + calculus of constructions (CoC)
+ Calculus of constructions
  + Higher-order typed lambda calculus
  + Curry-Howard
+ Propositions are types, proofs are terms (programs)
  + Proving = type checking
+ Lean uses CIC + universe polymorphism

** Type theory of Lean
+ Dependent type theory
+ Types can depend on values

#+BEGIN_SRC lean4
def divide (x y : Nat) (h : y ≠ 0) : Nat := x / y
#+END_SRC

+ Types can be indexed by runtime values

#+BEGIN_SRC lean4
def head {α : Type} {n : Nat} : Vector α (n + 1) → α
| ⟨data, h⟩ => data[0]
#+END_SRC

#+REVEAL: split
A dependent type theoretic implementation of the function

~head~: [α] → α

#+BEGIN_SRC lean4
inductive NonEmptyList (α : Type) where
| mk : (xs : List α) → xs ≠ [] → NonEmptyList α

def NonEmptyList.head {α} : NonEmptyList α → α
| .mk (x :: _) _ => x
| .mk [] h => (h rfl).elim
#+END_SRC

+ Type of the function already guarantees correctness
+ Impossible cases are removed by logical reasoning
+ No runtime errors

* Theorem Proving
+ p \to q is a proposition
  + but also a function that takes a term of type p as input and outputs a term of type q
+ Two ways
  + Construct lambda terms of the required type
  + Tactic mode
** Tactics
+ Two important tactics are ~intro~ and ~apply~
+ ~intro~ (assume, declaration)
  + introduces or brings assumptions in local context
  + want to prove p → q → r
  + bring proofs of ~p~ and ~q~ in the local context
+ ~apply~ (function application)
  + want to prove ~r : Prop~
  + suppose we have the function (constructor) x : a → r
  + ~apply x~ would reduce the goal to proving ~a~

#+REVEAL: split
+ Local context
+ Goal (or goals or subgoals)
  + Applying f : p → q → r → s to the goal s will gives us three subgoals p, q and r

#+BEGIN_SRC lean4
example (P Q : Nat → Prop) : (∃ x, P x ∧ Q x) → ∃ x, Q x ∧ P x := by
  intro h
  cases h with
  | intro k hpq =>
    cases hpq with
    | intro hp hq => constructor ; apply And.intro ; exact hq ; exact hp
#+END_SRC

+ A brief demo of tactic mode

** Lambda terms as proofs
+ To prove p → q, we write a lambda term of that type
+ Can switch between tactic mode and term mode
+ An example below (resolution rule)

#+BEGIN_SRC lean4
example : (p ∨ A) ∧ (¬p ∨ B) → A ∨ B :=
  fun ⟨ha, hb⟩ =>
  match ha with
  | Or.inl hp =>
    match hb with
    | Or.inl hnp => absurd hp hnp
    | Or.inr h   => Or.inr h
  | Or.inr h  => Or.inl h
#+END_SRC

#+REVEAL: split
Lean also provides tools for working with Classical logic

+ For any proposition ~p~, ~Classical.em p~ gives a term of type ~p ∨ ¬p~.

#+BEGIN_SRC lean4
example : ¬(p ∧ ¬q) → (p → q) :=
  fun h : ¬(p ∧ ¬q) =>
  fun hp =>
  Or.elim (Classical.em q)
  (fun hq  :  q => hq)
  (fun hnq : ¬q => absurd ⟨hp, hnq⟩ h)
#+END_SRC

+ ~if else~ and Pierce's law
Using if else automatically activates Classical.em

#+BEGIN_SRC lean4
example : ((p → q) → p) → p :=
  fun h =>
  if hp : p then hp
  else let hpq : p → q := fun hp' => absurd hp' hp
  h hpq
#+END_SRC

* Functional Programming
** Inductive types
#+BEGIN_SRC lean4
inductive Even : Nat → Prop
| zero : Even 0
| next : ∀ n : Nat, Even n → Even (n + 2)
#+END_SRC

Inductive types for logical connectives

#+BEGIN_SRC lean4
inductive And' (p q : Prop) : Prop
| intro : p → q → And' p q
#+END_SRC

#+BEGIN_SRC lean4
inductive Or' : Prop → Prop → Prop
| inl : p → Or' p q
| inr : q → Or' p q
#+END_SRC

#+REVEAL: split
Inductive definition gives constructors and destructors

+ Use constructors as introduction rules
+ Use case analysis on constructors (cases/induction) as elimination rules

The following are elimination rules for And.

#+BEGIN_SRC lean4
theorem And'.left : And' p q → p := by
  intro hpq
  cases hpq with
  | intro => assumption                    -- use of unnamed hypotheses

theorem And'.right : And' p q → q := by
  intro hpq
  cases hpq with
  | intro => assumption
#+END_SRC

#+REVEAL: split
A simple example (p ∧ q → q ∧ p):

#+BEGIN_SRC lean4
example (p q : Prop) : And' p q → And' q p := by
  intro hpq
  have hp : p := And'.left  hpq
  have hq : q := And'.right hpq
  exact And'.intro hq hp
#+END_SRC

#+REVEAL: split
Likewise, for existential statements and XOR operations.

#+BEGIN_SRC lean4
inductive Exists' {α : Type} (P : α → Prop) : Prop
| intro : (a : α) → P a → Exists' P

inductive Xor' : Prop → Prop → Prop
| inl : p → ¬q → Xor' p q
| inr : ¬p → q → Xor' p q
#+END_SRC

** Monads
+ Type constructor (Type → Type)
+ Two functions
  + pure (return, unit)
  + bind (join, multiplication)
+ Obeys three laws
  + Two identity laws
  + Associativity

#+BEGIN_SRC lean4
class Monad' (m : Type → Type) where
pure : α → m α
bind : m α → (α → m β) → m β

class LawfulMonad' (m : Type → Type) extends Monad' m where
pure_bind (a : α) (f : α → m β) :
  bind (pure a) f = f a
bind_pure (ma : m α) :
  bind ma (pure) = ma
bind_assoc (f : α → m β) (g : β → m γ) (ma : m α) :
  bind (bind ma f) g = bind ma (fun a => bind (f a) g)
#+END_SRC

#+REVEAL: split
Why monads?

+ Write pure functional programs in imperative style
+ All tactics proofs are just monadic operations
  + Tactic execution, logging, metavariable manipulation, backtracking, etc. are effectful
  + Tactics must fail cleanly (~throwError~), try alternatives (~try~, ~first~), brach, backtrack automatically
+ Metaprogramming (we will see soon enough)
+ Verification (we will see soon enough)

** Anatomy of a tactic proof
+ ~MetaM~, ~TacticM~ monads
+ Every tactic execution
  + reads environment (~Env~)
  + mutates goal state
  + may fail
  + may backtrack
  + may log messages
+ Monads allows this composition so smoothly

#+REVEAL: split
+ Every tactic (e.g., ~intro~, ~apply~, ~rw~, ~simp~) is a function\\
   TacticState → TacticM TacticState
  + reads the current state
  + performs an effect (modify goal, intro a binder, etc.)
  + returns the new state
  + or throws an error

* Automation
+ Built-in tactics
  + ~rw~, ~simp~
+ Tactic combinators
  + ~tac_1 <;> tac_2~
  + ~repeat' tac~
  + ~any_goals tac~
  + ~all_goals tac~
+ ~syntax~ and ~macro_rules~
  + Wrap up a procedure (or a programmed bunch of tactics) into one tactic
** Metaprogramming monads
~MetaM~, ~TacticM~ are metaprogramming monads
+ Manipulate goals and local context
+ Iterate over local context
+ Change goal list, close a goal

Using the built-in eliminator for AND:

#+BEGIN_SRC lean4
example (h : a ∧ b ∧ c ∧ d) : d := by apply And.right (And.right (And.right h))
#+END_SRC

With custom tactic ~destruct_and~:

#+BEGIN_SRC lean4
example (h : a ∧ b ∧ c ∧ d) : c := by destruct_and h
#+END_SRC

Another example is ~prove_direct~.

* Verification
+ Monads encode computations (~Option~, ~StateM~, ~TacticM~)
+ A computation or a program can be thought of as a monad (M α)
+ Specification monad (W α) specific to a monad M α
+ Weakest precondition transformer WP_M : M \alpha \to W \alpha
+ W is often chosen to be W α = (α → L) → L
+ Then WP : M α → (α → L) → L
** Loom
+ A framework for automated generation of foundational multi-modal verifiers
+ The theoretical basis (in their words, "our main theoretical result") lies in transformer monads and transformer monad algebras

#+REVEAL: split
+ M : monad (program)
+ L : assertion language (in which we will write preconditions and postconditions)
  + ~Prop~, σ → Prop
+ μ : M L → L (monad algebra)
  + Given a computation that would return a postcondition, return the precondition that guarantees that postcondition after running that computation
+ Define WP m post = μ (fmap post m)
  + Recall: post : α → L, m : M α, fmap post m : M L
+ Then WP has the type M α → (α → L) → L
+ Then the weakest precondition is given by WP m post

#+REVEAL: split
+ Monad transformer
  + Takes a monad, gives a monad
  + StateT transformer for StateM monad
    + StateT σ M α ≅ σ → M (α × σ)
  + MaybeT M α ≅ M (Option α)
+ Why use monad transformers?
  + Reuse the WP machinery we already have for the underlying monad M, rather then re-prove everything from scratch for StateT σ M
  + Can lift monad algebra/WP through transformers

#+REVEAL: split
+ Monad transformer algebra
  + is a pair (T, F)
  + F (endofunctor) will transform base assertion language L into the assertion language F(L) of T M
    + e.g., for StateT, we have F L = σ → L
+ Lifted monad algebra
  + Fμ : T M (F L) → F L
  + Recall: underlying monad algebra μ : M L → L
+ Fμ gives monad algebra for the transformed monad T M at transformed language F L
+ How do we construct Fμ?
  + Use pattern-match on T and use μ
+ WP tm post = Fμ (fmap post tm)

#+REVEAL: split
How do we implement this for stateful computations?
+ Decide the assertion language, L = σ → Prop
+ Write definition of StateT (involves instantiation of MonadTransformer typeclass)
  + F L = σ → L (we saw this before)
+ Design μ : StateM (σ → Prop) → (σ → Prop) (involves proving laws of monad algebra)
+ Derive Fμ for StateT (algorithmic)
+ Mechanically evaluate WP m post = Fμ (fmap post m)
+ Generate verification conditions (VCs): ~pre1 => wp~ and hand off to an SMT solver
** Case Study: Cashmere
+ ~CashmereM~
  + ~NonDetT (ExceptT String (StateT Bal DivM))~
+ Bank operations
  + Cash withdrawal, deposits, etc.
+ DSL (imperative-style)
+ ~require~, ~ensure~

#+REVEAL: split
Examples of Cashmere programs
+ Withdraw an amount

#+BEGIN_SRC lean4
bdef withdraw (amount : Nat) returns (u: Unit)
  ensures balance + amount = balanceOld do
  balance := balance - amount
  return

prove_correct withdraw by
loom_solve
#+END_SRC

#+REVEAL: split
+ Withdraw session (withdrawing multiple amounts)

#+BEGIN_SRC lean4
open PartialCorrectness DemonicChoice in
bdef withdrawSession (amounts : List Nat) returns (u: Unit)
  ensures balance + amounts.sum = balanceOld do
  let mut tmp := amounts
  let balancePrev := balance
  while tmp.nonEmpty
  invariant balance + amounts.sum = balancePrev + tmp.sum
  do
    let amount := tmp.head!
    balance := balance - amount
    tmp := tmp.tail
  return

open PartialCorrectness DemonicChoice in
prove_correct withdrawSession by
loom_solve!
#+END_SRC
